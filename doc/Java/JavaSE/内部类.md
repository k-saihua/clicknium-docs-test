将一个类声明在类体中，这样的类称为内部类

Java的内部类分为四种

## 1. 静态内部类

- 使用static修饰，声明在类体中

- 静态内部类可以访问外部类的静态成员，不能访问非静态成员

- 示例

  ```java
  class A {
      static int x;
      static class B {
          // 此时B的修饰符是default,在同一包和类中可见。
          public int method(){
              return x+1;
          }
      }
  }
  ```

  此时，A类就相当于B这个内部类的包，例如A在day04这个包下，那么B所在的包就是day04.A下。

  创建B的实例有两种方法

  - 导包：`import day04.A.B`
  - 类名全称创建：`A.B b = new A.B();`

## 2. 成员内部类

- 声明在类体中，不能使用static修饰，具有类的成员特征。也就是说必须有类的实例，才能创建内部类的实例

- 内部类实例可以访问共享外部类的成员变量（包括静态和非静态）

- 成员内部类具有和成员变量相同的作用域

- 示例

  ```java
  Class A {
      int a = 1;
      static b = 2;
      class B {
          int add(){
              return a+b;
          }
      }
  }
  ```

  要创建B的实例，那么要借助A，即

  ```java
  A a1 = new A();
  B b1 = a1.new B();
  ```

## 3. 局部内部类

  包类声明在方法中，作用域类似于局部变量，局部内部类可以共享外部类的局部变量。

一旦局部内部类访问了外部类的局部变量，那么外部类的局部变量就默认是final的。

## 4. 匿名内部类

- 匿名内部类非常常见，可以写在任何地方，可以理解为一般的语句。

- 语法更像是创建对象

  ```java
  new Comparator<String>(){
  	// 继承了Comparator类，类体中可以使用所有类的语法
  };
  ```

- 匿名内部类是对原类的一个继承，同时还创建了实例(原类子类的实例)

- 匿名内部类中不能写构造器

- 匿名内部类可以从抽象类中继承或者接口中实现，必须提供抽象方法的实例

任何内部类都会编译成独立的.class文件

内部类最大的作用就是封装































