### 1. 对于Java的GC哪些内存需要回收

内存运行时 JVM 会有一个运行时数据区来管理内存。它主要包括 5 大部分:程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。而其中程序计数器、虚拟机栈、本地方法栈是每个线程私有的内存空间,随线程而生，随线程而亡。例如栈中每一个栈帧中分配多少内存基本上在类结构确定是哪个时就已知了，因此这 3 个区域的内存分配和回收都是确定的，无需考虑内存回收的问题。
但方法区和堆就不同了，一个接口的多个实现类需要的内存可能不一样,我们只有在程序运行期间才会知道会创建哪些对象,这部分内存的分配和回收都是动态的,GC 主要关注的是这部分内存。
**总而言之,GC 主要进行回收的内存是 JVM 中的方法区和堆;**

### 2. Java的GC什么时候回收垃圾

垃圾回收问题可以转换成：如何判断一个对象已经死去?

#### 2.1 如何判断对象死亡

##### 2.1.1 引用计数器

每当有地方引用这个对象时，计数器值加 1；当引用失效时，计数器值减 1。而当计数器的值为 0 时这个对象就不会再被使用，判断为已死。这种方法简单效率也高，但是不能解决循环引用的问题。比如对象 A 中有一个字段指向了对象 B，而对象 B 中也有一个字段指向了对象 A，而事实上他们俩都不再使用，但计数器的值永远都不可能为 0，也就不会被回收，然后就发生了内存泄露。这种方法现在已经被废弃了。
##### 2.1.2 可达性分析

在 Java，C#等语言中，比较主流的判定一个对象已死的方法是：可达性分析(Reachability Analysis)。
所有生成的对象都是一个称为"GC Roots"的根的子树。从 GC Roots 开始向下搜索,搜索所经过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链可以到达时，就称这个对象是不可达的(不可引用的)，
也就是可以被 GC 回收了。

#### 2.2 Java中的引用类型

无论是引用计数器还是可达性分析，判定对象是否存活都与引用有关！那么，如何定义对象的引用呢？
我们希望给出这样一类描述：当内存空间还够时，能够保存在内存中；如果进行了垃圾回收之后内存空间仍旧非
常紧张，则可以抛弃这些对象。所以根据不同的需求，给出如下四种引用，根据引用类型的不同，GC 回收时也会有不
同的操作：

##### 2.2.1 强引用

Object obj = new Object()；只要强引用还存在， GC 永远不会回收掉被引用的对象。

##### 2.2.2 软引用

描述一些还有用但非必需的对象。在系统将会发生内存溢出之前，会把这些对象列入回收范围进行二次回收(即系统将会发生内存溢出了，才会对他们进行回收。)

##### 2.2.3 弱引用

程度比软引用还要弱一些。这些对象只能生存到下次 GC 之前。当 GC 工作时，无论内存是否足够都会将其回收(即只要进行 GC,就会对他们进行回收。)

##### 2.2.4 虚引用

一个对象是否存在虚引用，完全不会对其生存时间构成影响。

#### 2.3 需要回收什么

##### 2.3.1 方法区

关于方法区中需要回收的是一些废弃的常量和无用的类。

- 废弃的常量的回收。这里看引用计数就可以了。没有对象引用该常量就可以放心的回收了。

- 无用的类的回收。什么是无用的类呢?

  - 该类所有的实例都已经被回收。也就是 Java 堆中不存在该类的任何实例;
  - 加载该类的 ClassLoader 已经被回收;
  - 该类对应的 java.lang.Class 对象没有任何地方被引用,无法在任何地方通过反射访问该类的方法。

##### 2.3.2 堆内存

对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而
根据我们实际对引用的不同需求，又分成了 4 中引用，每种引用的回收机制也是不同的。

总而言之，对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类，就可以被回收了。